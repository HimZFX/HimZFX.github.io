<script>
(function() {
    const canvas = document.getElementById('bgCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let width, height;
    let stars = [];
    let angleOffset = 0; // 3D æ—‹è½¬è§’åº¦
    
    // --- âš™ï¸ ç”¨æˆ·å®šåˆ¶ç‰©ç†å‚æ•° ---
    const STAR_COUNT = 3;
    const G = 0.5;
    const SOFTENING = 10;       // å·¨å¤§çš„è½¯åŒ–å› å­å¸¦æ¥æå…¶å¹³æ»‘çš„è¿åŠ¨
    const TRAIL_LENGTH = 600;     // è¶…é•¿æ‹–å°¾
    const FRICTION = 1;     // æä½é˜»å°¼
    const CENTER_PULL = 0.000005; // æå¼±å‘å¿ƒåŠ›

    // --- ğŸ¥ 3D ç›¸æœºå‚æ•° ---
    const ROTATION_SPEED = 0.001; // é•œå¤´æ—‹è½¬é€Ÿåº¦
    const SCALE = 0.8;            // ç¼©æ”¾æ¯”ä¾‹ (é˜²æ­¢é£å‡ºå±å¹•å¤ªè¿œ)
    const Z_DEPTH = 800;          // Zè½´æ·±åº¦å½±å“å› å­ (æ§åˆ¶è¿‘å¤§è¿œå°çš„ç¨‹åº¦)

    // --- ğŸ¨ é¢œè‰²æ–¹æ¡ˆ ---
    const colors = {
        dark: [
            { color: '#00f2ff', glow: '#00f2ff' }, 
            { color: '#ff0055', glow: '#ff0055' }, 
            { color: '#ffe600', glow: '#ffe600' }  
        ],
        light: [
            { color: '#003366', glow: 'transparent' }, 
            { color: '#800000', glow: 'transparent' }, 
            { color: '#2F4F4F', glow: 'transparent' }  
        ]
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        if(stars.length === 0) initStars(); 
    }

    // --- æ ¸å¿ƒå·¥å…·ï¼š3Dç‚¹æŠ•å½±åˆ°2Då±å¹• ---
    function project(x, y, z) {
        // ç»• Y è½´æ—‹è½¬çŸ©é˜µå…¬å¼
        const cosA = Math.cos(angleOffset);
        const sinA = Math.sin(angleOffset);
        // æ—‹è½¬åçš„åæ ‡
        const rotX = x * cosA - z * sinA;
        const rotZ = x * sinA + z * cosA;
        const rotY = y;

        // è®¡ç®—æ·±åº¦ç¼©æ”¾å› å­ (è¿‘å¤§è¿œå°)
        // z è¶Šå¤§(è¶Šè¿œ)ï¼Œscale è¶Šå°
        let depthScale = Z_DEPTH / (Z_DEPTH + rotZ);
        // é™åˆ¶ä¸€ä¸‹ç¼©æ”¾èŒƒå›´ï¼Œé˜²æ­¢å¤ªè¿‘å˜å¾—æ— é™å¤§
        depthScale = Math.max(0.1, Math.min(2.0, depthScale));

        // æŠ•å½±åˆ°å±å¹•ä¸­å¿ƒ
        const screenX = width / 2 + rotX * SCALE * depthScale;
        const screenY = height / 2 + rotY * SCALE * depthScale;

        return { x: screenX, y: screenY, scale: depthScale, zIndex: rotZ };
    }

    class Star {
        constructor(index) {
            this.index = index;
            this.reset();
        }

        reset() {
            // åœ¨ 3D ç©ºé—´ä¸­åˆå§‹åŒ–
            const spread = Math.min(width, height) * 0.5;
            this.x = (Math.random() - 0.5) * spread;
            this.y = (Math.random() - 0.5) * spread;
            this.z = (Math.random() - 0.5) * spread; // æ–°å¢ Z è½´

            this.vx = (Math.random() - 0.5) * 1.5;
            this.vy = (Math.random() - 0.5) * 1.5;
            this.vz = (Math.random() - 0.5) * 1.5; // æ–°å¢ Z é€Ÿåº¦

            this.mass = 100 + Math.random() * 100; 
            this.baseRadius = Math.sqrt(8 + this.mass/100);
            // history ç°åœ¨å­˜å‚¨ 3D ç‚¹
            this.history = [];
            // é¢„å…ˆå¡«å…… history é¿å…åˆæœŸé—ªçƒ
            for(let i=0; i<TRAIL_LENGTH; i++) this.history.push({x:this.x, y:this.y, z:this.z});
        }

        update() {
            // 1. 3D Nä½“å¼•åŠ›è®¡ç®— (ä¿æŒä¸å˜)
            for (let other of stars) {
                if (other === this) continue;
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dz = other.z - this.z;
                
                const distSq = dx*dx + dy*dy + dz*dz;
                const dist = Math.sqrt(distSq);
                
                const force = (G * this.mass * other.mass) / (distSq + SOFTENING);
                
                this.vx += (force * dx / dist) / this.mass;
                this.vy += (force * dy / dist) / this.mass;
                this.vz += (force * dz / dist) / this.mass;
            }

            // 2. 3D å‘å¿ƒåŠ› & æ‘©æ“¦ (ä¿æŒä¸å˜)
            this.vx += (0 - this.x) * CENTER_PULL;
            this.vy += (0 - this.y) * CENTER_PULL;
            this.vz += (0 - this.z) * CENTER_PULL;
            
            this.vx *= FRICTION;
            this.vy *= FRICTION;
            this.vz *= FRICTION;

            // 3. æ›´æ–°ä½ç½® (ä¿æŒä¸å˜)
            this.x += this.vx;
            this.y += this.vy;
            this.z += this.vz;

            // --- ğŸš€ æ–°å¢ï¼š3D è¾¹ç•Œé‡ç½®æœºåˆ¶ ---
            // è®¡ç®—å½“å‰è·ç¦»ä¸­å¿ƒçš„è·ç¦»å¹³æ–¹ (x^2 + y^2 + z^2)
            const distSqFromCenter = this.x * this.x + this.y * this.y + this.z * this.z;
            
            // è®¾å®šé€ƒé€¸åŠå¾„ (2500 åƒç´ å¤§çº¦æ˜¯å±å¹•å®½åº¦çš„ 1.5-2 å€ï¼Œè¶³å¤Ÿè¿œ)
            const ESCAPE_RADIUS = 2000; 

            // å¦‚æœè·ç¦»è¶…è¿‡äº†é€ƒé€¸åŠå¾„ï¼Œé‡ç½®ï¼
            if (distSqFromCenter > ESCAPE_RADIUS * ESCAPE_RADIUS) {
                this.reset();
                return; // ç»“æŸæœ¬æ¬¡æ›´æ–°
            }
            // -------------------------------

            // 4. è®°å½• 3D è½¨è¿¹ (ä¿æŒä¸å˜)
            this.history.push({x: this.x, y: this.y, z: this.z});
            if (this.history.length > TRAIL_LENGTH) this.history.shift();
        }

        draw(isDark) {
            const theme = isDark ? colors.dark : colors.light;
            const style = theme[this.index % theme.length];

            // æŠ•å½±å½“å‰ä½ç½®ï¼Œè·å–æ·±åº¦ç¼©æ”¾
            const proj = project(this.x, this.y, this.z);
            // æ ¹æ®æ·±åº¦è°ƒæ•´åŠå¾„ (è¿‘å¤§è¿œå°)
            const currentRadius = this.baseRadius * proj.scale;
            // æ ¹æ®æ·±åº¦è°ƒæ•´åŸºç¡€é€æ˜åº¦ (è¶Šè¿œè¶Šæ·¡)
            const baseAlpha = Math.max(0.2, Math.min(1.0, proj.scale));

            // A. ç»˜åˆ¶è¶…é•¿ 3D æ‹–å°¾
            ctx.beginPath();
            // ä¸ºäº†æ€§èƒ½ï¼Œè¶…é•¿æ‹–å°¾ä¸éœ€è¦æ¯å¸§éƒ½ç”»ï¼Œéš”ç‚¹é‡‡æ ·
            const sampleRate = 2; 
            for (let i = 0; i < this.history.length - sampleRate; i += sampleRate) {
                // å…³é”®ï¼šè½¨è¿¹ä¸Šçš„æ¯ä¸ªç‚¹éƒ½è¦å®æ—¶æŠ•å½±
                const p3d1 = this.history[i];
                const p3d2 = this.history[i+sampleRate];
                
                const p1 = project(p3d1.x, p3d1.y, p3d1.z);
                const p2 = project(p3d2.x, p3d2.y, p3d2.z);
                
                const ratio = i / this.history.length; // 0.0 (å°¾) -> 1.0 (å¤´)
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                
                // é€æ˜åº¦ = åŸºç¡€æ·±åº¦é€æ˜åº¦ * å°¾è¿¹æ¸å˜
                const finalAlpha = baseAlpha * ratio;
                
                if (isDark) {
                    // é»‘å¤œï¼šè¿œå¤„æ‹–å°¾æ›´ç»†æ›´æ·¡
                    ctx.strokeStyle = `rgba(255, 255, 255, ${finalAlpha * 0.5})`;
                    ctx.lineWidth = ratio * 3 * p1.scale; // çº¿å®½ä¹Ÿéšæ·±åº¦ç¼©æ”¾
                } else {
                    // ç™½å¤©
                    ctx.strokeStyle = `rgba(0, 0, 0, ${finalAlpha * 0.15})`;
                    ctx.lineWidth = ratio * 2 * p1.scale;
                }
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // B. ç»˜åˆ¶æ˜Ÿä½“æœ¬ä½“ (å¦‚æœåœ¨è§†é‡å‰æ–¹)
            if (proj.scale > 0) {
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = style.color;
                
                // åº”ç”¨æ·±åº¦é€æ˜åº¦
                ctx.globalAlpha = baseAlpha;
                
                if (isDark) {
                    // è¾‰å…‰ä¹Ÿéšè·ç¦»ç¼©æ”¾
                    ctx.shadowBlur = 20 * proj.scale;
                    ctx.shadowColor = style.glow;
                } else {
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0; // é‡ç½®å…¨å±€é€æ˜åº¦
            }
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push(new Star(i));
        }
    }

    function animate() {
        // 1. æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, width, height);

        // 2. å…‰çº¿ä¼ æ„Ÿå™¨
        let isDark = false;
        try {
            const bgColor = window.getComputedStyle(document.body).backgroundColor;
            const rgb = bgColor.match(/\d+/g);
            if (rgb) {
                const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                isDark = brightness < 128;
            }
        } catch (e) {
            isDark = document.body.classList.contains('dark');
        }

        // 3. æ›´æ–°ç›¸æœºè§’åº¦
        angleOffset += ROTATION_SPEED;

        // 4. ç‰©ç†æ›´æ–°ä¸ç»˜åˆ¶
        // ä¸ºäº†æ­£ç¡®çš„é®æŒ¡å…³ç³»ï¼ˆè™½ç„¶è¿™é‡Œä¸é‡è¦ï¼Œä½†å¥½ä¹ æƒ¯ï¼‰ï¼Œå¯ä»¥æŒ‰ Z è½´æ’åºåå†ç”»
        // stars.sort((a, b) => project(b.x, b.y, b.z).zIndex - project(a.x, a.y, a.z).zIndex);

        for (let star of stars) {
            star.update();
            star.draw(isDark);
        }

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    initStars(); 
    animate();
})();
</script>