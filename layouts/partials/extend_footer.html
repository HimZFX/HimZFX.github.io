<script>
(function() {
    const canvas = document.getElementById('bgCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let width, height;
    let stars = [];
    
    // --- âš™ï¸ ç‰©ç†å‚æ•° ---
    const STAR_COUNT = 3;
    const G = 0.5;
    const SOFTENING = 1000;       
    const TRAIL_LENGTH = 100;     // æ‹–å°¾é•¿åº¦å¯ä»¥ç¨å¾®é•¿ä¸€ç‚¹ï¼Œæ¸å˜æ›´å¥½çœ‹
    const FRICTION = 0.99999;      
    const CENTER_PULL = 0.000015;  

    // --- ğŸ¨ é¢œè‰²æ–¹æ¡ˆ ---
    const colors = {
        dark: [
            { color: '#00f2ff', glow: '#00f2ff' }, 
            { color: '#ff0055', glow: '#ff0055' }, 
            { color: '#ffe600', glow: '#ffe600' }  
        ],
        light: [
            { color: '#003366', glow: 'transparent' }, 
            { color: '#800000', glow: 'transparent' }, 
            { color: '#2F4F4F', glow: 'transparent' }  
        ]
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        if(stars.length === 0) initStars(); 
    }

    class Star {
        constructor(index) {
            this.index = index;
            this.reset();
        }

        reset() {
            this.x = width / 2 + (Math.random() - 0.5) * Math.min(width, height) * 0.5;
            this.y = height / 2 + (Math.random() - 0.5) * Math.min(width, height) * 0.5;
            this.vx = (Math.random() - 0.5) * 3;
            this.vy = (Math.random() - 0.5) * 3;
            this.mass = 80 + Math.random() * 40; 
            this.radius = Math.sqrt(8 + Math.random());
            this.history = [];
        }

        update() {
            // Nä½“å¼•åŠ›è®¡ç®—
            for (let other of stars) {
                if (other === this) continue;
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);
                const force = (G * this.mass * other.mass) / (distSq + SOFTENING);
                const ax = (force * dx / dist) / this.mass;
                const ay = (force * dy / dist) / this.mass;
                this.vx += ax;
                this.vy += ay;
            }
            this.vx += (width / 2 - this.x) * CENTER_PULL;
            this.vy += (height / 2 - this.y) * CENTER_PULL;
            this.vx *= FRICTION;
            this.vy *= FRICTION;
            this.x += this.vx;
            this.y += this.vy;
            
            // è®¾å®šä¸€ä¸ªè¾¹è· (margin)ï¼Œè®©æ˜Ÿæ˜Ÿé£å‡ºå±å¹• 200px åå†é‡ç½®
            // è¿™æ ·èƒ½ä¿è¯å°¾è¿¹æ˜¯è‡ªç„¶æ¶ˆå¤±ï¼Œè€Œä¸æ˜¯åœ¨å±å¹•è¾¹ç¼˜çªç„¶æˆªæ–­
            const margin = 200;
            if (this.x < -margin || this.x > width + margin || 
                this.y < -margin || this.y > height + margin) {
                this.reset(); // é£å¤ªè¿œäº†ï¼Ÿå›æ¥å§ï¼
                return;       // é‡ç½®åç›´æ¥ç»“æŸæœ¬æ¬¡æ›´æ–°
            }

            this.history.push({x: this.x, y: this.y});
            if (this.history.length > TRAIL_LENGTH) this.history.shift();
        }

        draw(isDark) {
            const theme = isDark ? colors.dark : colors.light;
            const style = theme[this.index % theme.length];

            // A. ç»˜åˆ¶æ¸å˜æµæ˜Ÿå°¾è¿¹
            // ä¸å†æ˜¯ä¸€ç¬”ç”»ï¼Œè€Œæ˜¯å¾ªç¯ç”»æ¯ä¸€å°æ®µ
            for (let i = 0; i < this.history.length - 1; i++) {
                const p1 = this.history[i];
                const p2 = this.history[i+1];
                
                // ratio: 0.0 (å°¾å·´å°–) -> 1.0 (æ˜Ÿæ˜Ÿå¤´)
                const ratio = i / this.history.length;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                
                if (isDark) {
                    // ğŸŒ™ é»‘å¤œæ¨¡å¼ï¼šç™½è‰²å‘å…‰æ‹–å°¾
                    // é€æ˜åº¦ä» 0 æ¸å˜åˆ° 0.4
                    ctx.strokeStyle = `rgba(255, 255, 255, ${ratio * 0.4})`;
                    // å®½åº¦ä» 0 æ¸å˜åˆ° 3
                    ctx.lineWidth = ratio * 3;
                } else {
                    // â˜€ï¸ ç™½å¤©æ¨¡å¼ï¼šæ·±è‰²å¢¨è¿¹
                    // é€æ˜åº¦ä» 0 æ¸å˜åˆ° 0.2 (éå¸¸æ·¡ï¼Œåœ¨ç™½åº•ä¸Šé€æ¸æ¶ˆå¤±å˜ç™½)
                    ctx.strokeStyle = `rgba(0, 0, 0, ${ratio * 0.2})`;
                    // å®½åº¦ä» 0 æ¸å˜åˆ° 2
                    ctx.lineWidth = ratio * 2;
                }
                
                ctx.lineCap = 'round'; // è®©çº¿æ®µè¿æ¥å¤„åœ†æ»‘
                ctx.stroke();
            }

            // B. ç»˜åˆ¶æ˜Ÿä½“
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = style.color;
            if (isDark) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = style.glow;
            } else {
                ctx.shadowBlur = 0;
            }
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push(new Star(i));
        }
    }

    function animate() {
        ctx.clearRect(0, 0, width, height);

        // å…‰çº¿ä¼ æ„Ÿå™¨
        let isDark = false;
        try {
            const bgColor = window.getComputedStyle(document.body).backgroundColor;
            const rgb = bgColor.match(/\d+/g);
            if (rgb) {
                const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                isDark = brightness < 128;
            }
        } catch (e) {
            isDark = document.body.classList.contains('dark');
        }

        for (let star of stars) {
            star.update();
            star.draw(isDark);
        }

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    initStars(); 
    animate();
})();
</script>